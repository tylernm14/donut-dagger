require 'sinatra/activerecord'

class Job < ActiveRecord::Base

  ActiveRecord::Base.raise_in_transactional_callbacks = true
  attr_readonly :uuid, :completed?

  enum status: [ :waiting, :launched, :queued, :running, :succeeded, :failed, :terminated, :dead ]

  default_scope { order('created_at desc') }
  scope :by_uuid,   -> (uuid)   { where uuid: uuid }
  scope :by_status, -> (status) { where status: Job.statuses[status] }
  scope :by_workflow_uuid, -> (uuid) { where workflow_id: Workflow.find_by_uuid(uuid).id }

  belongs_to :workflow
  has_and_belongs_to_many :dependencies, class_name: 'Job', join_table: 'job_edges', foreign_key: :dependent_id, association_foreign_key: :dependency_id
  has_and_belongs_to_many :dependents, class_name: 'Job', join_table: 'job_edges', foreign_key: :dependency_id, association_foreign_key: :dependent_id

  validates_presence_of :status, :workflow, :name

  # used to load the uuid generated by the database
  after_validation :create_uuid, on: :create
  after_commit :reload, on: :create
  after_commit :eval_dag, on: :update, :if => Proc.new { |job| updated_to_completed?(job) }
  # dependent cleanup of the join table
  before_destroy :delete_job_edges

  def completed?
    failed? or succeeded? or terminated? or dead?
  end

  def dependencies_remaining
    self.dependencies.count - self.dependencies.select { |j| j.completed? }.count
  end

  def dependencies_completed
    self.dependencies.select {|j| j.completed?}.count
  end

  def result_count
    begin
      Result.all(params: { by_job_id: self.id }).count
    rescue StandardError => e
      puts e
      -1
    end
  end

  private

  def updated_to_completed?(job)
    #puts "PREV: #{job.previous_changes}"
    job.previous_changes.key?('status') &&
    job.previous_changes['status'].first != job.previous_changes['status'].last &&
    job.completed? &&
    job.previous_changes['status'].first == 'running'
  end

  def delete_job_edges
    JobEdge.where("dependent_id = ? OR dependency_id = ?", self.id, self.id).destroy_all
  end

  def eval_dag
    JobDoneWorker.perform_async(self.id)
  end


  def create_uuid
    unless self.uuid
      self.uuid = SecureRandom.uuid
    end
  end

end
